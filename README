/////////////////////////////////////////////////////////////////
//
// Personuppgifter (namn, pnr, epost) på dem som gjort labben
//


/////////////////////////////////////////////////////////////////
//
// 1.1
//
// vad betyder \$* i en makefile? 


// vad gör -Wall och -g ?


/////////////////////////////////////////////////////////////////
//
// 1.2 a)
// 
// int powerof(int x, int y) {
//     int res = 1;
//     for (int i = 0; i < y; i++); {
//         res *= x;
//     }
//     return res;
// }
// 
// int main() {
//     int x = 10;
//     int y = 3;
// 
//     int res = powerof(x, y);
// 
//     std::cout << x << " upphöjt till " << y << " är " << res << std::endl;
// 
//     float z = 0.29;
//     int w = (int) (z * x * x);
//     if (z * x * x == 29)
//         std::cout << z << "*" << x * x << " är 29" << std::endl;
//     else
//         std::cout << z << "*" << x * x << " är inte 29" << std::endl;           
// }
// 
// Varför blir värdet på variabeln w inte det man tror (0.29*100)? 

    0.29 kan inte lagras exakt som en float utan blir 0.289999992.
    Sedan blir det avrundat neråt när man castar det till en int.


// Hur många varv körs for-loopen i funktionen powerof? 

    for-loopen har bara ett tomt statement (ett ;) och det körs y gånger.
    Koden efter som ser ut att tillhöra loopen, loopas inte och körs en enda
    gång.


// 1.2 b)
//
// int must_follow_a(char * start, int length, char a, char b) {
//     int nr = 0;
//     for (int i = 0; i < length; i++, ++start) {
//         if (*start == a && *(start + 1) == b) // maintainers note: DANGER!
//             nr += 1;
//     }
//     return nr;
// }
// 
// Dina tre testfall

    // Checks string with a repeated pattern with two characters.
    void test_b_repeated_twice( void )
    {
        char vek[] = {'a', 'b', 'a', 'b', 'x'};
        int result = must_follow_a(vek, 4, 'a', 'b');
        TS_ASSERT_EQUALS(result, 2);
    }
    
    // Checks off-by-one problem with length.
    void test_c_length_off_by_one( void )
    {
        char vek[] = {'b', 'b', 'a', 'b', 'b'};
        int result = must_follow_a(vek, 3, 'a', 'b');
        TS_ASSERT_EQUALS(result, 0);
    }
    
    // Tests with an empty vector.
    void test_d_( void )
    {
        char vek[] = {};
        int result = must_follow_a(vek, 0, 'a', 'b');
        TS_ASSERT_EQUALS(result, 0);
    }

// Varför är det så viktigt att testa randvillkoren?

    För att minnet utanför vektorer är odefinerat. Om man skickar in en hel
    vektor och funktionen läser utanför den kan man få olika resultat med
    olika kompilatorer eller under körningarna. Det är inte säkert att man
    upptäcker problemet då, och det kan vara svårt att felsöka.


/////////////////////////////////////////////////////////////////
//
// 1.3 
// 
// Bifoga källkoden till din version av A.cpp


// Vad skriver ditt program ut, var förberedd att förklara varför. 


// När frigörs objekten?  


// När skapas temporära objekt?

//   A b = a;         // vad är skillnaden
//   A c(a);          // mellan dessa
//   A d;             // tre tekniker?


//   no_ref(a);       // Bildas temporära objekt?


//   with_ref(a);     // Bildas temporära objekt?


//   delete aa;       // Vad kommer att hända


/////////////////////////////////////////////////////////////////
//
// struct Data {
//     int x, y, z;
// };  
// 
// Data ** foo(Data ** v, int x) {
//     for (int i = 0; i < x; i++)
//         //if (v[i] != 0)
//             v[i] = new Data;
//     return v;
// }
// 
// int main () {
//     const int size = 5;
//     Data ** v = new Data * [size];
//     Data ** p = foo(v, size);
//     delete [] p;
// }

// Hur ser valgrinds felmeddelande ut?  


// Blir det någon skillnad i hur mycket minne som läcker när man
// kommenterar if-satsen?


// Borde det ha blivit någon skillnad?


// Varför läcker programmet fortfarande minne?


/////////////////////////////////////////////////////////////////
//
// 1.4
//
// Generellt är det ofta en god idé att låta konstruktorer som
// tar ett argument deklareras som explicit. Varför? Ange ett
// exempel där det annars kan bli dumt.


// operatorn[] måste vara en konstant medlemsfunktion i vissa
// fall. När och varför? Hur kopierar man vektorn?


